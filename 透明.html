<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>透明处理</title>
	<link rel="stylesheet" type="text/css" href="./public-file/css/style.css">
	<style>
		#canvas{
			width: 10rem;
            height:10rem;
            position: fixed;
			top:50%;
			transform: translateY(-50%);	
		}
	</style>
</head>
<body>
	<canvas id="canvas"></canvas>
	<script src="./common/flexible.js"></script>
	<script src="./common/webgl-utils.js"></script>
	<script src="./common/initShaders.js"></script>
	<script src="./common/MV.js"></script>
	<script id="vertex-shader" type="x-shader/vertex-shader">
        attribute vec4 vPosition;
        attribute vec4 lightPosition;
        attribute vec4 vNormal;
		uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        uniform vec4 ambientProduct;
        uniform vec4 diffuseProduct;
        uniform vec4 specularProduct;
        uniform float shininess;
        uniform mat3 normalMatrix;
        varying vec4 fColor;
		void main()
		{   
            vec3 pos = (modelViewMatrix * vPosition).xyz;
			vec3 light = lightPosition;
			vec3 L = normalize(light - pos); //光线的方向向量
			vec3 E = normalize(-pos);//这是观察方向向量
			vec3 H = normalize(L + E);//这是半角向量
			vec3 N = normalize(normalMatrix * vNormal);
			float Kd = max(dot(L, N),0.0);
			vec4 diffuse = Kd * diffuseProduct;
			float Ks = pow(max(dot(L, H), 0.0), shininess);
			vec4 specular = Ks * specularProduct;
			vec4 ambient = ambientProduct;
			fColor = ambient + diffuse + specular;
			fColor.a = 1.0;
            gl_Position = projectionMatrix * modelViewMatrix * vPosition;
		}
	</script>
	<script id="fragment-shader" type="x-shader/fragment-shader">
        precision mediump float;
        varying vec4 fColor;
        void main()
        {   
            gl_FragColor = fColor;
		}
	</script>
    <script type="text/javascript">
		var pointCircleArray = []; //存放圆形顶点数据
        var pointTriangleArray = []; //存放正三角形顶点数据
        var pointCircleNormalArray = []; //存放圆形法向量数据
        var pointTriangleNormalArray = [];//存放正三角形法向量数据

        var n = 10; 
        // 把圆形分成10等份
        //则y=-5*1/n,-4*1/n,-3/n,-2/n,-1/n,0,1/n,2/n,3/n,4/n,5/n
        var m = 18;
        //把一个圆分成18份，则每一份为20度
        var rowArr = [];
        // 先把正y轴上的最顶点push进rowArr里面
        rowArr.push([vec4(0,0.5,0,0.5)]); //不透明度为0.5
        for(var i = 0; i < n-1; i++) {
            //此时y为0.5 - (i+1)/6
            var y = 0.5 - (i+1)/6;
            var t = 1 - y * y;
            var R = Math.sqrt(t);
            var tarr = [];
            for(var j=0;j < m; j++) {
                var theta = 360/m * j;
                var tx = Math.cos(theta) * R;
                var tz = Math.sin(theta) * R;
                tarr.push(vec4(tx,y,tz));
            }
            rowArr.push(tarr);
        }
        //最后把y轴上的最底面的哪个点push进rowArr里面
        rowArr.push([vec4(0,-0.5,0,0.5)]);
        
        
		function initFn () {
			var canvas = document.getElementById('canvas');
			var canvasClientWidth = canvas.clientWidth;
			var canvasClientHeight = canvas.clientHeight;
			canvas.width = canvasClientWidth;
			canvas.height = canvasClientHeight;
			var gl = WebGLUtils.setupWebGL(canvas);
			if (!gl) {
				alert('您当前的浏览器不支持webgl');
			}
			gl.viewport(0,0,canvas.width,canvas.height);
			gl.clearColor(1,1,1,1);
			gl.enable(gl.DEPTH_TEST);
			let program = initShaders(gl,'vertex-shader', 'fragment-shader');
			gl.useProgram(program);
			//点
			var vPositionLoc = gl.getAttribLocation(program, 'vPosition');
			var positionBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
			gl.bufferData(gl.ARRAY_BUFFER,flatten(pointArray), gl.STATIC_DRAW);
            gl.vertexAttribPointer(vPositionLoc, 4, gl.FLOAT, false, 0, 0);
			gl.enableVertexAttribArray(vPositionLoc);            
      		//模-视矩阵
			var modelLoc = gl.getUniformLocation(program,'modelViewMatrix');
			var eye = vec3(0,0,3);
			var at = vec3(0,0,0);
			var up = vec3(0,1,0);
            var modelViewMatrix = lookAt(eye,at,up);
            modelViewMatrix = mult(modelViewMatrix,translate(0,0,1));
            // modelViewMatrix = mult(modelViewMatrix,scale(0.5,[1,1,1]));
      		//投影矩阵
			var projectionLoc = gl.getUniformLocation(program,'projectionMatrix');
            var projectionMatrix = perspective(60,1,1,3);
			gl.uniformMatrix4fv(projectionLoc,false,flatten(projectionMatrix));
			//法向量矩阵
			var normalMatrixLoc = gl.getUniformLocation(program, 'normalMatrix');
			

			function render() {
				gl.clearColor(1,1,1,1);
			    modelViewMatrix = mult(modelViewMatrix, rotate(0.3,[1,1,1]));
				gl.uniformMatrix4fv(modelLoc,false,flatten(modelViewMatrix));
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER);
                gl.drawArrays( gl.TRIANGLES, 0, pointArray.length);
				requestAnimationFrame(render)
			}
			render();
		}
		initFn();
	</script>
</body>
</html>
